# -*- coding: utf-8 -*-
"""calories_burnt_prediction.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1bRuMXpzUWZ4YKFHcm1iixzQgcaKmFOu7
"""

#!pip install opendatasets

"""# **1. Data Downloading and Loading**

**1.0 Import requred dependencies and libraries.**
"""

import matplotlib.pyplot as plt
import pandas as pd
import numpy as np
import seaborn as sns

from sklearn.linear_model import LinearRegression
from sklearn.ensemble import RandomForestRegressor
from xgboost import XGBRegressor

from sklearn.metrics import r2_score,mean_absolute_error,mean_squared_error
from sklearn.model_selection import train_test_split
from sklearn.preprocessing import LabelEncoder

import opendatasets
import os
import warnings
warnings.filterwarnings('ignore')
import pickle
import joblib
sns.set()

import sklearn
print(sklearn.__version__)

"""**Downloading dataset from kaggle using opendatasets**"""

dataset_url = 'https://www.kaggle.com/datasets/fmendes/fmendesdat263xdemos'
opendatasets.download(dataset_url)
#{"username":"your_kaggle_username","key"api_key"}

"""**Loading dataset to Pandas DatsFrame**"""

def csv_to_dataframe(csv_file:str)-> pd.DataFrame:
  file_extension = os.path.splitext(csv_file)[1]

  file_name = os.path.basename(csv_file)
  print(f'File name: {file_name}')
  print(f'File extention: {file_extension}')

  if file_extension != '.csv':
    raise ValueError(f'File: {file_name} is not csv file')
  
  try:
    df = pd.read_csv(csv_file)
    print(f'File: {file_name} have been successfully loaded\n')
    return df
  except FileNotFoundError as e:
    raise FileNotFoundError(f'file: {file_name} with path: {csv_file} is not found. {e}')
  
  except pd.errors.ParserError as e:
    raise ValueError(f'Error while parsing csv file:{file_name}. {e}')

calories_csv_path = '/content/fmendesdat263xdemos/calories.csv'
exercise_csv_path = '/content/fmendesdat263xdemos/exercise.csv'
calories_dataframe = csv_to_dataframe(calories_csv_path)
exercise_dataframe = csv_to_dataframe(exercise_csv_path)

# Top five rows 
calories_dataframe.head()

# Top five rows 
exercise_dataframe.head()

#add Calories column to exercise dataframe
exercise_dataframe['Calories'] = calories_dataframe['Calories']
exercise_dataframe.head(10)

"""#**2. Descriptive Analysis**"""

#shape of the dataframe
exercise_dataframe.shape

#size of the dataframe
exercise_dataframe.size

#columns in the dataframe
exercise_dataframe.columns.tolist()

#information about the dataframe
exercise_dataframe.info()

#data types of the dataframe
exercise_dataframe.dtypes

# statistical information about numerical columns
exercise_dataframe.describe()

#categorical column statistics
exercise_dataframe.describe(include = 'object')

"""#**3. Data Visualization**

**Checking misssing Values**
"""

exercise_dataframe.isnull().sum()

"""**Drop unnecessary columnns**"""

exercise_dataframe.drop('User_ID',axis=1,inplace = True)

numerical_columns =list(exercise_dataframe.select_dtypes(['int64','float64']).columns)
numerical_columns

# visualizing numerical columns using boxplot,violinplot,histogram,kde,
def make_plot(df:pd.DataFrame,plot_kind:str, numerical_columns:list):
  
  if df.empty:
    raise ValueError(f'This dataframe is empty.')

  plot_func = {
      'violinplot':sns.violinplot,
      'boxplot':sns.boxplot,
      'kde':sns.kdeplot,
      'hist': plt.hist
  }

  if plot_kind not in plot_func.keys():
    raise ValueError(f'{plot_kind} is invalid plotting function \n consider using: {list(plot_func.keys())}')

  if not isinstance(numerical_columns,list):
    raise TypeError(f'Must be a list containng the names of columns')


  fig = plt.figure(figsize=(15,10))
  for index,column in enumerate(numerical_columns):

    axis = fig.add_subplot(3,3,index+1)
    if plot_kind not in ['hist','kde']:
      plot_func[plot_kind](y=df[column],ax=axis)
      plt.title(f'{plot_kind} plot for {column}')
    else:
      plot_func[plot_kind](df[column])
      plt.title(f'{plot_kind} plot for {column}')
  plt.tight_layout()
  plt.show()

#boxplot
make_plot(exercise_dataframe,'boxplot',numerical_columns)

#violinplot
make_plot(exercise_dataframe,'violinplot',numerical_columns)

#barplot
make_plot(exercise_dataframe,'hist',numerical_columns)

#kde plot
make_plot(exercise_dataframe,'kde',numerical_columns)

"""**Visualizing Gender column**"""

gender = exercise_dataframe.Gender.value_counts()
gender

gender.plot(kind = 'bar')
plt.title('Distribution of Genders')
plt.show()

gender.plot(kind = 'pie',autopct = '%.f%%')
plt.title('Distribution of Genders')
plt.show()

"""**Correlation matrix**"""

correlation = exercise_dataframe.corr()
correlation

sns.heatmap(correlation,annot=True,fmt='.1f',cmap = 'Reds')
plt.show()

"""**Feature Engineering**

**Calculate BMI**
"""

def calculate_BMI(dataframe: pd.DataFrame) ->pd.DataFrame:
  height_weight_tuple = ('Height','Weight')
  
  if not all(column in dataframe.columns for column in height_weight_tuple):
    raise ValueError("Missing 'Height' and 'Weight' column in dataframe")
  
  dataframe['BMI'] = dataframe['Weight']/((dataframe['Height']/100)**2)
  return dataframe
  

calculate_BMI(exercise_dataframe)

"""**BMI Index Category**"""

def feature_engineer_bmi_category(dataframe:pd.DataFrame,bmi_range:list,bmi_labels:list):
  dataframe['BMI Category'] = pd.cut(dataframe['BMI'],bins=bmi_range,labels=bmi_labels)
  return dataframe

bmi_range = [0,18.5,25,30,40]
bmi_labels = ['Underweight','Normal Weight','Overweight','Obese']
feature_engineer_bmi_category(exercise_dataframe,bmi_range,bmi_labels)

"""**Age Group**"""

mycopy = exercise_dataframe.copy()

def feature_engineer_age_category(dataframe:pd.DataFrame,age_range:list,labels:str):
  
  dataframe['Age Group'] = pd.cut(dataframe['Age'],bins=age_ranges,labels=labels)
  return dataframe

age_ranges = [0,14,24,64,100]
labels = ['Children','Youth','Adult','Old']

feature_engineer_age_category(exercise_dataframe,age_ranges,labels)

"""**Save final data to csv,excel and json**"""

exercise_dataframe.to_csv('exercise_df.csv',sep='\t',encoding='utf-8')
exercise_dataframe.to_excel('exercise_df.xlsx',index = False)
exercise_dataframe.to_json('exercise_df.json',indent = 4,orient='records')

"""**Label Encoding**"""

def label_encoding(dataframe:pd.DataFrame):

  """
    Encodes the 'Gender' column of the given DataFrame using a LabelEncoder,
    and creates dummy variables for the 'Age Group' and 'BMI Category' columns.

    Args:
        dataframe (pandas.DataFrame): The DataFrame to be encoded.

    Returns:
        pandas.DataFrame: A new DataFrame with the encoded 'Gender' column and
        dummy variables for the 'Age Group' and 'BMI Category' columns.
  """
  encoder = LabelEncoder()
  dataframe['Gender'] = encoder.fit_transform(dataframe['Gender'])
  dataframe = pd.get_dummies(dataframe,columns = ['Age Group','BMI Category'])
  return dataframe 
new_df = label_encoding(exercise_dataframe)
new_df

"""**Seperating features from target**"""

features = new_df.drop('Calories',axis=1)
target = new_df['Calories']

features

"""**Train Test Split**"""

def split_data(features, target, test_size=0.2, random_state=3):
    """
    Splits the given features and target data into train and test sets using
    a train-test split with the specified test size and random state.

    Args:
        features (pandas.DataFrame): The features data to be split.
        target (pandas.Series): The target data to be split.
        test_size (float): The proportion of the data to use for testing.
            Default is 0.2.
        random_state (int): The random seed to use for splitting the data.
            Default is 3.

    Returns:
        tuple: A tuple containing the train and test features data and
            corresponding labels in the format (train_data, test_data,
            train_labels, test_labels).
    """
    train_data, test_data, train_labels, test_labels = train_test_split(
        features, target, test_size=test_size, random_state=random_state)
    return train_data, test_data, train_labels, test_labels

train_data,test_data,train_labels,test_labels = split_data(features,target)

train_data



"""**Modeling**"""

#linear regression

linear_model = LinearRegression()
linear_model.fit(train_data,train_labels)
linear_model_prediction = linear_model.predict(test_data)

accuracy = r2_score(test_labels,linear_model_prediction)
MSE = mean_squared_error(test_labels,linear_model_prediction)
MAE = mean_absolute_error(test_labels,linear_model_prediction)
print("Accuracy of the model:", round(accuracy,2),'%')
print("Mean absolute error:", MAE)
print("Mean squared error:", MSE)

#prediction vs actual value on testing data
linear_df = pd.DataFrame({'Actual Label':test_labels,'Predicted Label':linear_model_prediction})
linear_df.head(20)

"""**Training with many model**"""

models = [LinearRegression(),XGBRegressor(),RandomForestRegressor()]
def compare_model(models,train_data,train_labels,test_data,test_labels):
  models_result = []
  for model in models:
    model.fit(train_data,train_labels)
    prediction = model.predict(test_data)
    accuracy = r2_score(test_labels,prediction)
    MSE = mean_squared_error(test_labels,prediction)
    MAE = mean_absolute_error(test_labels,prediction)

    models_result.append({
        'Model Name': str(model),
        'Model Accuracy':accuracy,
        'Mean Absolute Error':MAE,
        'Mean Squared Error':MSE
    })
  return pd.DataFrame(models_result).sort_values(by='Model Accuracy',ascending=False)
compare_model(models,train_data,train_labels,test_data,test_labels)

"""**XGBRegressor had a highest score**"""

XGB_model = XGBRegressor()
XGB_model.fit(features,target)
XGB_model_prediction = XGB_model.predict(test_data)
XGB_model_accuracy = r2_score(test_labels,XGB_model_prediction)
print('Final model Accuracy: ',XGB_model_accuracy,'%')

#prediction vs actual value on testing data using xgbregrressor
xgb_df = pd.DataFrame({'Actual Label':test_labels,'Predicted Label':XGB_model_prediction})
xgb_df.head(20)

"""**Saving model using pickle and joblib**"""

joblib.dump(XGB_model,'xgbregressor_model.joblib')
pickle.dump(XGB_model,open('xgbregressor_model.pickle','wb'))

"""**Predictive system**"""

model_path  = '/content/xgbregressor_model.pickle'
try:
  with open(model_path,'rb') as f:
    model = pickle.load(f)
    print('Model have been successfully loaded')
except:
  print('Problem loading the pickle file')

features = pd.DataFrame([{
        'Gender':'female',
        'Age':20,
        'Height':180,
        'Weight':65,
        'Duration':90,
        'Heart_Rate':40,
        'Body_Temp':70
    }])
def preprocess_data(df):
  '''
  preprocess data for fastapi
  
  '''
  df['Gender'] = df['Gender'].map({'female':0,'male':1})
  df['BMI'] = df['Weight']/((df['Height']/100)**2)
  df['BMI Category'] = pd.cut(df['BMI'],bins = [0,18.5,25,30,40],labels = ['Underweight','Normal Weight','Overweight','Obese'])
  df['Age Group'] = pd.cut(df['Age'],bins= [0,14,24,64,100], labels = ['Children','Youth','Adult','Old'])
  df = pd.get_dummies(df,columns = ['Age Group','BMI Category'])
  return df

data = preprocess_data(features)
model.predict(data)[0]